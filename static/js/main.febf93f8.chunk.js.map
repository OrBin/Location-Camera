{"version":3,"sources":["Camera.js","round.js","Geolocation.js","DefaultIcon.js","TargetMap.js","Orientation.js","App.js","serviceWorker.js","index.js"],"names":["Camera","props","render","className","audio","videoConstraints","facingMode","state","videoSize","width","height","updateWindowDimensions","bind","this","window","addEventListener","removeEventListener","setState","innerWidth","innerHeight","Component","round","value","Math","roundCoordinate","coordinate","Geolocation","innerDiv","geolocationMessage","coords","latitude","longitude","map","altitude","heading","defaultIcon","Icon","iconUrl","iconAnchor","shadowUrl","TargetMap","selfCoords","targetCoords","Map","center","zoom","TileLayer","url","Marker","position","icon","Orientation","orientation","absolute","alpha","beta","gamma","toRadians","angle","PI","App","ypr","yawDeg","pitchDeg","rollDeg","ned","Ned","nedUpdateCount","processLocation","isGeolocationAvailable","isGeolocationEnabled","handleOrientation","event","yawRad","pitchRad","east","sin","north","cos","up","calculatePointingLocation","selfLocation","LatLon_NvectorEllipsoidal","selfOrientation","scaledOrientation","down","targetPoint","destinationPoint","toString","elevation","bearing","atan2","toDegrees","prevProps","geolocated","Boolean","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.febf93f8.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport Webcam from 'react-webcam';\n\nclass Camera extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { width: 0, height: 0 };\n    this.updateWindowDimensions = this.updateWindowDimensions.bind(this);\n  }\n\n  componentDidMount() {\n    this.updateWindowDimensions();\n    window.addEventListener('resize', this.updateWindowDimensions);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.updateWindowDimensions);\n  }\n\n  updateWindowDimensions() {\n    this.setState({\n      videoSize: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n      }\n    });\n  }\n\n  render = () => (\n    <Webcam\n      className={'camera'}\n      audio={false}\n      videoConstraints={\n        {\n          facingMode: \"environment\",\n          ...this.state.videoSize,\n        }\n      }\n    />\n  );\n}\n\nexport default Camera;\n","\nconst round = value => Math.round(value * 100) / 100;\n\nexport {\n  round,\n};\n","import React from 'react';\nimport { round } from './round';\n\nconst coordinatesDigitsAfterPoint = 4;\nconst roundCoordinate = coordinate => (Math.round(coordinate*(10**coordinatesDigitsAfterPoint)) / (10**coordinatesDigitsAfterPoint));\nconst Geolocation = ({geolocationMessage, coords}) => {\n  let innerDiv;\n  if (!coords) {\n    innerDiv = (<div>{geolocationMessage}</div>);\n  } else {\n    let {latitude, longitude} = coords;\n    [latitude, longitude] = [latitude, longitude].map(roundCoordinate);\n\n    innerDiv = (\n      <div>\n        {`${latitude}, ${longitude})`}\n        {coords.altitude ? `, ${round(coords.altitude)}m` : `, ${round(coords.height)}m`}\n        {coords.heading ? `, hdg: ${round(coords.heading)}` : null}\n      </div>\n    )\n  }\n\n  return (\n    <div className={'geolocation'}>\n      {innerDiv}\n    </div>\n  );\n}\n\nexport default Geolocation;\n","// A patch to prevent an \"Invalid URL\" error; See https://github.com/Leaflet/Leaflet/issues/6822\nimport { Icon } from 'leaflet';\n\nconst defaultMarker = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=';\nconst defaultMarkerShadow = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC';\nconst defaultIcon = new Icon({\n  iconUrl: defaultMarker,\n  iconAnchor: [12, 41],\n  shadowUrl: defaultMarkerShadow,\n});\n\nexport default defaultIcon;\n","import React from 'react'\nimport { Map, Marker, TileLayer } from 'react-leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport defaultIcon from './DefaultIcon';\n\n\nconst TargetMap = ({selfCoords, targetCoords}) => {\n  return (\n    <>\n      <div>\n        {\n        (selfCoords && targetCoords)\n        ?\n        <Map className={'map'} center={[selfCoords.latitude, selfCoords.longitude]} zoom={14}>\n          <TileLayer url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" />\n          <Marker position={[targetCoords.latitude, targetCoords.longitude]} icon={defaultIcon}></Marker>\n        </Map>\n        :\n        null\n        }\n      </div>\n    </>\n  );\n}\n\nexport default TargetMap;\n","import React from 'react';\nimport { round } from './round';\n\nconst Orientation = ({orientation}) => (\n  <div className={'orientation'}>\n    {\n      orientation\n      ?\n      <div>\n        {`Absolute: ${orientation.absolute}, `}\n        {`α: ${round(orientation.alpha)}, `}\n        {`β: ${round(orientation.beta)}, `}\n        {`γ: ${round(orientation.gamma)}`}\n      </div>\n      :\n      <div>No orientation available</div>\n    }\n  </div>\n);\nexport default Orientation;\n","import React, { Component } from 'react';\nimport { geolocated } from \"react-geolocated\";\nimport LatLon_NvectorEllipsoidal, {Ned} from \"geodesy/latlon-nvector-ellipsoidal\";\nimport './App.css';\nimport Camera from './Camera';\nimport Geolocation from './Geolocation';\nimport TargetMap from './TargetMap';\nimport Orientation from './Orientation';\n\nconst toRadians = angle => angle * (Math.PI / 180);\n\nclass App extends Component {\n  state = {\n    coords: null,\n    geolocationMessage: '',\n    orientation: null,\n    ypr: {yawDeg: 0, pitchDeg: 0, rollDeg: 0},\n    ned: new Ned(0, 0, 0),\n    nedUpdateCount: 0\n  }\n  componentDidMount() {\n    this.processLocation();\n    window.addEventListener('deviceorientationabsolute', this.handleOrientation, true);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps !== this.props) {\n      this.processLocation();\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('deviceorientationabsolute', this.handleOrientation, true);\n  }\n\n  processLocation = () => {\n    if (!this.props.isGeolocationAvailable) {\n      this.setState({coords: null, geolocationMessage: \"Your browser does not support Geolocation\"});\n    } else if (!this.props.isGeolocationEnabled) {\n      this.setState({coords: null, geolocationMessage: \"Geolocation is not enabled\"});\n    } else if (!this.props.coords) {\n      this.setState({coords: null, geolocationMessage: \"Getting location data...\"});\n    } else {\n      this.setState({coords: this.props.coords, geolocationMessage: null});\n    }\n  };\n\n  handleOrientation = event => {\n    this.setState({orientation: event})\n    let {alpha, beta, gamma} = event;\n    let [yawDeg, pitchDeg, rollDeg] = [360-alpha, beta - 90, gamma];\n    if (pitchDeg < -180) {\n      pitchDeg += 360;\n    }\n    this.setState({ypr: {yawDeg, pitchDeg, rollDeg}})\n\n    const [yawRad, pitchRad] = [yawDeg, pitchDeg].map(toRadians)\n\n    const east = Math.sin(yawRad);\n    const north = Math.cos(yawRad);\n    const up =  Math.sin(pitchRad);\n\n    const ned = new Ned(north, east, -up);\n    this.setState({ned: ned});\n    this.calculatePointingLocation();\n  };\n\n  calculatePointingLocation = () => {\n    if (!this.state.ned || !this.state.coords) {\n      return;\n    }\n    const {latitude, longitude, altitude} = this.state.coords;\n    const selfLocation = new LatLon_NvectorEllipsoidal(latitude, longitude, altitude)\n    const selfOrientation = this.state.ned;\n\n    const scaleFactor = 100;\n    let scaledOrientation = new Ned(selfOrientation.north * scaleFactor, selfOrientation.east * scaleFactor, selfOrientation.down * scaleFactor);\n    let targetPoint = selfLocation.destinationPoint(scaledOrientation);\n    this.setState({targetPoint,})\n  };\n\n  render = () => (\n    <>\n      <Geolocation\n        geolocationMessage={this.state.geolocationMessage}\n        coords={this.state.coords}\n      />\n      <Orientation orientation={this.state.orientation}/>\n      <div className={'orientation'}>\n        {\n          `Yaw: ${Math.round(this.state.ypr.yawDeg)}, \n          Pitch: ${Math.round(this.state.ypr.pitchDeg)}, \n          Roll: ${Math.round(this.state.ypr.rollDeg)}`\n        }\n      </div>\n      <div className={'orientation'}>\n        {\n          `NED: ${this.state.ned.toString(2)}`\n        }\n      </div>\n      <div className={'orientation'}>\n        {\n          `Elevation: ${Math.round(this.state.ned.elevation)} Bearing: ${Math.round(this.state.ned.bearing)}\n          atan2(E,N)=${Math.round(Math.atan2(this.state.ned.east, this.state.ned.north).toDegrees())}`\n        }\n      </div>\n      <Geolocation\n        coords={this.state.targetPoint}\n      />\n      <TargetMap\n        className={'map-container'}\n        selfCoords={this.state.coords}\n        targetCoords={this.state.targetPoint}\n      />\n      <Camera/>\n    </>\n  );\n}\n\nexport default geolocated({})(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}